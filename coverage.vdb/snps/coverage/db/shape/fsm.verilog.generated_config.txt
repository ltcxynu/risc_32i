// Synopsys, Inc.
// User: host
// Date: Sat Sep 28 23:59:04 2024

// ==================================================================================================
// This config file prototype is produced from the last run using the complete list of extracted fsms.
// Please note that by providing your own description of the module you are enforcing what will be
// extracted for that module.
// Copy this file to your source directory and edit it as described below,
// then pass the file to VCS using the -cm_fsmcfg command line option.
// FSMs will be extracted normally for any module not mentioned in this file
// ==================================================================================================
// 1. For every module that you want to specify yourself, use:
//      MODULE==name
//    -----------------------------------------------------
//    The following options are defining the behavior on the module level.
//    -----------------------------------------------------
//    1.1  You can control what fsms should be used within this module:
//            FSMS=AUTO
//            this means that you want VCS to automatically extract all
//            detectable FSMs from this module.
//            -----------------------------------------------------
//            FSMS=EXCLUDE
//            this means that you want all fsms except the ones from the list that follows
//            if the list is empty, all fsms will be extracted for this module
//            -----------------------------------------------------
//            FSMS=RESTRICT
//            this means that you want only the fsms from the list that follows
//            if the list is empty, no fsms will be extracted for this module
//            -----------------------------------------------------
//         If none of these options are specified, the program will assume FSMS=RESTRICT
//         -----------------------------------------------------
//     1.2 You can specify that the state with the minimal value should be used as a
//         start state for all sequences in every fsm in the module.
//            FSMS=START_STATE_DFLT
//         For any particular fsm you can overwrite this behavior inside its description.
//    -----------------------------------------------------
// 2. Each fsm description in the list of fsms should be specified as follows:
//      2.1 provide the current state variable declaration:
//          CURRENT= name of the current state variable
//      -----------------------------------------------------
//      2.2 if next state variable is different from the current state provide:
//          NEXT= next state variable
//          if you don't use NEXT=, the program will assume that CURRENT and NEXT are the same
//      -----------------------------------------------------
//      2.3 if you want to provide the restrictive the list of states, provide:
//          STATES= s0,s1 etc. where s0 is either a name or a value of the state
//          if you don't use STATES=, the program will assume that you want to use all states
//      -----------------------------------------------------
//      2.4 if you want to ignore some states, specify them in the following list:
//          STATES_X= s0,s1, etc.
//      -----------------------------------------------------
//      2.5 if you want to mark, that some states should never be reached, specify them as a list:
//          STATES_NEVER= s0,s1, etc.
//      -----------------------------------------------------
//      2.6 similar to the STATES, if you want to provide the restrictive the list of transitions, specify:
//          TRANSITIONS= s0->s1,s1->s2, etc.
//      -----------------------------------------------------
//      2.7 similar to the STATES_X, if you want to ignore some transitions, specify them in the following list:
//          TRANSITIONS_X= s0->s1,s1->s2, etc.
//      -----------------------------------------------------
//      2.8 similar to the STATES_NEVER,if you want to mark, that some transitions should never occur,
//          specify them as a list:
//          TRANSITIONS_NEVER= s0->s1,s1->s2,     etc.
//      -----------------------------------------------------
//      2.9 if you want to specify the start state use:
//          START_STATE= s0
//      -----------------------------------------------------
//      Please note:
//          - that a state in every list can be specified either by name or by value.
//          - in specifying the transitions you can use * in order to refer to 'any' state.
// ==================================================================================================
// Uncomment and modify the following 2 line to override default FSM sequence limits for all FSMs in the design.
//SEQ_NUMBER_MAX=10000
//SEQ_LENGTH_MAX=32

MODULE=clint
CURRENT=csr_state
NEXT=csr_state
STATES=S_CSR_IDLE,S_CSR_MCAUSE,S_CSR_MEPC,S_CSR_MSTATUS,S_CSR_MSTATUS_MRET
TRANSITIONS=S_CSR_IDLE->S_CSR_MEPC,
S_CSR_IDLE->S_CSR_MSTATUS_MRET,
S_CSR_MCAUSE->S_CSR_IDLE,
S_CSR_MEPC->S_CSR_IDLE,
S_CSR_MEPC->S_CSR_MSTATUS,
S_CSR_MSTATUS->S_CSR_IDLE,
S_CSR_MSTATUS->S_CSR_MCAUSE,
S_CSR_MSTATUS_MRET->S_CSR_IDLE
MODULE=timer
CURRENT=timer_ctrl
NEXT=timer_ctrl
STATES=['h1],['h2],['h4]
TRANSITIONS=['h1]->['h4]
MODULE=full_handshake_tx
CURRENT=state
NEXT=state_next
STATES=STATE_ASSERT,STATE_DEASSERT,STATE_IDLE
TRANSITIONS=STATE_ASSERT->STATE_DEASSERT,
STATE_ASSERT->STATE_IDLE,
STATE_DEASSERT->STATE_IDLE,
STATE_IDLE->STATE_ASSERT
MODULE=uart_debug
CURRENT=state
NEXT=state
STATES=S_CLEAR_UART_RX_OVER_FLAG,S_CRC_CALC,S_CRC_END,S_CRC_START,S_GET_BYTE,S_IDLE,S_INIT_UART_BAUD,S_REC_FIRST_PACKET,S_REC_REMAIN_PACKET,S_SEND_ACK,S_SEND_NAK,S_WAIT_BYTE,S_WAIT_BYTE2,S_WRITE_MEM
TRANSITIONS=S_CLEAR_UART_RX_OVER_FLAG->S_IDLE,
S_CLEAR_UART_RX_OVER_FLAG->S_WAIT_BYTE,
S_CRC_CALC->S_CRC_END,
S_CRC_CALC->S_IDLE,
S_CRC_END->S_IDLE,
S_CRC_END->S_SEND_ACK,
S_CRC_END->S_SEND_NAK,
S_CRC_END->S_WRITE_MEM,
S_CRC_START->S_CRC_CALC,
S_CRC_START->S_IDLE,
S_GET_BYTE->S_CLEAR_UART_RX_OVER_FLAG,
S_GET_BYTE->S_CRC_START,
S_GET_BYTE->S_IDLE,
S_IDLE->S_INIT_UART_BAUD,
S_INIT_UART_BAUD->S_IDLE,
S_INIT_UART_BAUD->S_REC_FIRST_PACKET,
S_REC_FIRST_PACKET->S_CLEAR_UART_RX_OVER_FLAG,
S_REC_FIRST_PACKET->S_IDLE,
S_REC_REMAIN_PACKET->S_CLEAR_UART_RX_OVER_FLAG,
S_REC_REMAIN_PACKET->S_IDLE,
S_SEND_ACK->S_IDLE,
S_SEND_ACK->S_REC_FIRST_PACKET,
S_SEND_ACK->S_REC_REMAIN_PACKET,
S_SEND_NAK->S_IDLE,
S_SEND_NAK->S_REC_FIRST_PACKET,
S_SEND_NAK->S_REC_REMAIN_PACKET,
S_WAIT_BYTE->S_IDLE,
S_WAIT_BYTE->S_WAIT_BYTE2,
S_WAIT_BYTE2->S_GET_BYTE,
S_WAIT_BYTE2->S_IDLE,
S_WRITE_MEM->S_IDLE,
S_WRITE_MEM->S_SEND_ACK
MODULE=jtag_driver
CURRENT=jtag_state
NEXT=jtag_state
STATES=CAPTURE_DR,CAPTURE_IR,EXIT1_DR,EXIT1_IR,EXIT2_DR,EXIT2_IR,PAUSE_DR,PAUSE_IR,RUN_TEST_IDLE,SELECT_DR,SELECT_IR,SHIFT_DR,SHIFT_IR,TEST_LOGIC_RESET,UPDATE_DR,UPDATE_IR
TRANSITIONS=CAPTURE_DR->EXIT1_DR,
CAPTURE_DR->SHIFT_DR,
CAPTURE_DR->TEST_LOGIC_RESET,
CAPTURE_IR->EXIT1_IR,
CAPTURE_IR->SHIFT_IR,
CAPTURE_IR->TEST_LOGIC_RESET,
EXIT1_DR->PAUSE_DR,
EXIT1_DR->TEST_LOGIC_RESET,
EXIT1_DR->UPDATE_DR,
EXIT1_IR->PAUSE_IR,
EXIT1_IR->TEST_LOGIC_RESET,
EXIT1_IR->UPDATE_IR,
EXIT2_DR->SHIFT_DR,
EXIT2_DR->TEST_LOGIC_RESET,
EXIT2_DR->UPDATE_DR,
EXIT2_IR->SHIFT_IR,
EXIT2_IR->TEST_LOGIC_RESET,
EXIT2_IR->UPDATE_IR,
PAUSE_DR->EXIT2_DR,
PAUSE_DR->TEST_LOGIC_RESET,
PAUSE_IR->EXIT2_IR,
PAUSE_IR->TEST_LOGIC_RESET,
RUN_TEST_IDLE->SELECT_DR,
RUN_TEST_IDLE->TEST_LOGIC_RESET,
SELECT_DR->CAPTURE_DR,
SELECT_DR->SELECT_IR,
SELECT_DR->TEST_LOGIC_RESET,
SELECT_IR->CAPTURE_IR,
SELECT_IR->TEST_LOGIC_RESET,
SHIFT_DR->EXIT1_DR,
SHIFT_DR->TEST_LOGIC_RESET,
SHIFT_IR->EXIT1_IR,
SHIFT_IR->TEST_LOGIC_RESET,
TEST_LOGIC_RESET->RUN_TEST_IDLE,
UPDATE_DR->RUN_TEST_IDLE,
UPDATE_DR->SELECT_DR,
UPDATE_DR->TEST_LOGIC_RESET,
UPDATE_IR->RUN_TEST_IDLE,
UPDATE_IR->SELECT_DR,
UPDATE_IR->TEST_LOGIC_RESET
MODULE=uart
CURRENT=state
NEXT=state
STATES=S_IDLE,S_SEND_BYTE,S_START,S_STOP
TRANSITIONS=S_IDLE->S_START,
S_SEND_BYTE->S_IDLE,
S_SEND_BYTE->S_STOP,
S_START->S_IDLE,
S_START->S_SEND_BYTE,
S_STOP->S_IDLE
